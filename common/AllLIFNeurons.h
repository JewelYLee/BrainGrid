/** 
 * @authors Aaron Oziel, Sean Blackbourn
 * 
 * @class AllIFNeurons AllIFNeurons.h "AllIFNeurons.h"
 * @brief A container of all LIF neuron data
 *
 *  The container holds neuron parameters of all neurons. 
 *  Each kind of neuron parameter is stored in a 1D array, of which length
 *  is number of all neurons. Each array of a neuron parameter is pointed by a 
 *  corresponding member variable of the neuron parameter in the class.
 *
 *  In this file you will find usage statistics for every variable in the BrainGrid 
 *  project as we find them. These statistics can be used to help 
 *  determine if a variable is being used, where it is being used, and how it
 *  is being used in each class::function()
 *  
 *  For Example
 *
 *  Usage:
 *  - LOCAL VARIABLE -- a variable for individual neuron
 *  - LOCAL CONSTANT --  a constant for individual neuron
 *  - GLOBAL VARIABLE -- a variable for all neurons
 *  - GLOBAL CONSTANT -- a constant for all neurons
 *
 *  Class::function(): --- Initialized, Modified OR Accessed
 *
 *  OtherClass::function(): --- Accessed   
 *
 *  Note: All GLOBAL parameters can be scalars. Also some LOCAL CONSTANT can be categorized 
 *  depending on neuron types. 
 *
 * A standard leaky-integrate-and-fire neuron model is implemented
 * where the membrane potential \f$V_m\f$ of a neuron is given by
 * \f[
 *   \tau_m \frac{d V_m}{dt} = -(V_m-V_{resting}) + R_m \cdot (I_{syn}(t)+I_{inject}+I_{noise})
 * \f]
 * where \f$\tau_m=C_m\cdot R_m\f$ is the membrane time constant,
 * \f$R_m\f$ is the membrane resistance, \f$I_{syn}(t)\f$ is the
 * current supplied by the synapses, \f$I_{inject}\f$ is a
 * non-specific background current and \f$I_{noise}\f$ is a
 * Gaussian random variable with zero mean and a given variance
 * noise.
 *
 * At time \f$t=0\f$ \f$V_m\f$ is set to \f$V_{init}\f$. If
 * \f$V_m\f$ exceeds the threshold voltage \f$V_{thresh}\f$ it is
 * reset to \f$V_{reset}\f$ and hold there for the length
 * \f$T_{refract}\f$ of the absolute refractory period.
 *
 * The exponential Euler method is used for numerical integration.
 * The main idea behind the exponential Euler rule is that many biological 
 * processes are governed by an exponential decay function.
 * For an equation of the form:
 * \f[
 *  \frac{d y}{dt} = A - By
 * \f]
 *
 * its scheme is given by:
 * \f[
 *  y(t+\Delta t) = y(t) \cdot \mathrm{e}^{-B \Delta t} + \frac{A}{B} \cdot (1 - \mathrm{e}^{-B \Delta t})
 * \f]
 *
 * After appropriate substituting all variables, we obtain the exponential Euler step:
 * \f[
 *  V_m(t+\Delta t) = V_m(t) \cdot \mathrm{e}^{-\frac{\Delta t}{\tau_m}} + 
 *  R_m \cdot (I_{syn}(t)+I_{inject}+I_{noise}+\frac{V_{resting}}{R_m}) 
 *  \cdot (1 - \mathrm{e}^{-\frac{\Delta t}{\tau_m}})
 * \f]
 *
 * Phenomenological model of frequency-dependent synapses exibit dynamics that include
 * activity-dependent facilitation and depression (Tsodyks and Markram 1997, Tsodyks et al. 1998). 
 * The model has two state variables: \f$r\f$ (the fraction of available synaptic efficacy), and
 * \f$u\f$ (the running value of utilization of synaptic efficacy).
 *
 * \f[
 *  r_{n+1} = r_n \cdot (1-u_{n+1}) \cdot \mathrm{e}^{-\frac{\Delta t}{\tau_{rec}}} +
 *  1 - \mathrm{e}^{-\frac{\Delta t}{\tau_{rec}}}
 * \f]
 *
 * \f[
 * \f]
 *
 * where \f$\Delta t\f$ is the time interval between nth and (n + 1)th AP,
 * the two time constants \f$\tau_{rec}\f$ and \f$\tau_{facil}\f$ govern recovery from depression,
 * and facilitation after a spike, and \f$U\f$ is utilization of synaptic efficacy (Markram et al. 1998).
 *
 * The synaptic response that is generated by any AP in a train is therefore given by:
 * \f[
 *  EPSP_n = A \cdot r_n \cdot u_n
 * \f]
 *
 * This model is a rewrite of work by Stiber, Kawasaki, Allan Ortiz, and Cory Mayberry
 *
 * @authors Derek McLean
 */
#pragma once

#include "Global.h"
#include "AllIFNeurons.h"
#include "AllSpikingSynapses.h"

// Class to hold all data necessary for all the Neurons.
class AllLIFNeurons : public AllIFNeurons
{
    public:

        AllLIFNeurons();
        virtual ~AllLIFNeurons();

#if defined(USE_GPU)
        // Update the state of all neurons for a time step
        virtual void advanceNeurons(AllSynapses &synapses, AllNeurons* allNeuronsDevice, AllSynapses* allSynapsesDevice, const SimulationInfo *sim_info, float* randNoise, SynapseIndexMap* synapseIndexMapDevice);
#else
        // Helper for #advanceNeuron. Updates state of a single neuron.
        virtual void advanceNeuron(const int index, const SimulationInfo *sim_info);

        // Initiates a firing of a neuron to connected neurons
        virtual void fire(const int index, const SimulationInfo *sim_info) const;
#endif

    private:
};

#if defined(__CUDACC__)
//! Perform updating neurons for one time step.
extern __global__ void advanceNeuronsDevice( int totalNeurons, int maxSynapses, int maxSpikes, const BGFLOAT deltaT, uint64_t simulationStep, float* randNoise, AllIFNeurons* allNeuronsDevice, AllSpikingSynapses* allSynapsesDevice, SynapseIndexMap* synapseIndexMapDevice, void (*fpPreSpikeHit)(const uint32_t, AllSpikingSynapses*), void (*fpPostSpikeHit)(const uint32_t, AllSpikingSynapses*), bool fAllowBackPropagation ); 
#endif
