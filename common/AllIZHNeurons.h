/** 
 * @authors Aaron Oziel, Sean Blackbourn
 * 
 * @class AllIZHNeurons AllIZHNeurons.h "AllIZHNeurons.h"
 * @brief A container of all LIF neuron data
 *
 *  The container holds neuron parameters of all neurons. 
 *  Each kind of neuron parameter is stored in a 1D array, of which length
 *  is number of all neurons. Each array of a neuron parameter is pointed by a 
 *  corresponding member variable of the neuron parameter in the class.
 *
 *  In this file you will find usage statistics for every variable in the BrainGrid 
 *  project as we find them. These statistics can be used to help 
 *  determine if a variable is being used, where it is being used, and how it
 *  is being used in each class::function()
 *  
 *  For Example
 *
 *  Usage:
 *  - LOCAL VARIABLE -- a variable for individual neuron
 *  - LOCAL CONSTANT --  a constant for individual neuron
 *  - GLOBAL VARIABLE -- a variable for all neurons
 *  - GLOBAL CONSTANT -- a constant for all neurons
 *
 *  Class::function(): --- Initialized, Modified OR Accessed
 *
 *  OtherClass::function(): --- Accessed   
 *
 *  Note: All GLOBAL parameters can be scalars. Also some LOCAL CONSTANT can be categorized 
 *  depending on neuron types. 
 *
 * The Izhikevich neuron model uses the quadratic integrate-and-fire model 
 * for ordinary differential equations of the form:
 * \f[
 *  \frac{d v}{dt} = 0.04v^2 + 5v + 140 - u + (I_{syn}(t) + I_{inject} + I_{noise})
 * \f]
 * \f[
 *  \frac{d u}{dt} = a \cdot (bv - u)
 * \f]
 * with the auxiliary after-spike resetting: if \f$v\ge30\f$ mv, then \f$v=c,u=u+d\f$.
 *
 * where \f$v\f$ and \f$u\f$ are dimensionless variable, and \f$a,b,c\f$, and \f$d\f$ are dimensioless parameters. 
 * The variable \f$v\f$ represents the membrane potential of the neuron and \f$u\f$ represents a membrane 
 * recovery variable, which accounts for the activation of \f$K^+\f$ ionic currents and 
 * inactivation of \f$Na^+\f$ ionic currents, and it provides negative feedback to \f$v\f$. 
 * \f$I_{syn}(t)\f$ is the current supplied by the synapses, \f$I_{inject}\f$ is a non-specific 
 * background current and Inoise is a Gaussian random variable with zero mean and 
 * a given variance noise (Izhikevich. 2003).
 *
 * The simple Euler method combined with the exponential Euler method is used for 
 * numerical integration. The main idea behind the exponential Euler rule is 
 * that many biological processes are governed by an exponential decay function. 
 * For an equation of the form:
 * \f[
 *  \frac{d y}{dt} = A - By
 * \f]
 * its scheme is given by:
 * \f[
 *  y(t+\Delta t) = y(t) \cdot \mathrm{e}^{-B \Delta t} + \frac{A}{B} \cdot (1 - \mathrm{e}^{-B \Delta t}) 
 * \f]
 * After appropriate substituting all variables, we obtain the Euler step:
 * \f[
 *  v(t+\Delta t)=v(t)+\Delta t \cdot (0.04v(t)^2+5v(t)+140-u(t))+R_{m} \cdot (I_{syn}(t)+I_{inject}+I_{noise}+\frac{V_{resting}}{R_{m}}) \cdot (1-\mathrm{e}^{-\frac{\Delta t}{\tau_{m}}})
 * \f]
 * \f[
 *  u(t+ \Delta t)=u(t) + \Delta t \cdot a \cdot (bv(t)-u(t))
 * \f]
 * where \f$\tau_{m}=C_{m} \cdot R_{m}\f$ is the membrane time constant, \f$R_{m}\f$ is the membrane resistance.
 * Phenomenological model of frequency-dependent synapses exibit dynamics that include 
 * activity-dependent facilitation and depression (Tsodyks and Markram 1997, Tsodyks et al. 1998). 
 * The model has two state variables: \f$r\f$ (the fraction of available synaptic efficacy), 
 * and \f$u\f$ (the running value of utilization of synaptic efficacy).
 * \f[
 *  r_{n+1}=r_{n} \cdot (1-u_{n+1}) \cdot \mathrm{e}^{-\frac{\Delta t}{\tau_{rec}}}+1-\mathrm{e}^{-\frac{\Delta t}{\tau_{rec}}}
 * \f]
 * \f[
 *  u_{n+1}=u_{n} \cdot \mathrm{e}^{-\frac{\Delta t}{\tau_{facil}}}+U \cdot (1-u_{n} \cdot \mathrm{e}^{-\frac{\Delta t}{\tau_{facil}}})
 * \f]
 * where \f$\Delta t\f$ is the time interval between nth and (n + 1)th AP, the two time constants 
 * \f$\tau_{rec}\f$ and \f$\tau_{facil}\f$ govern recovery from depression, and facilitation after a spike, 
 * and \f$U\f$ is utilization of synaptic efficacy (Markram et al. 1998).
 *
 * The synaptic response that is generated by any AP in a train is therefore given by:
 * \f[
 *  EPSP_{n}=A \cdot r_{n} \cdot u_{n}
 * \f]
 * This model is a rewrite of work by Stiber, Kawasaki, Allan Ortiz, and Cory Mayberry
 *
 * @authors Derek McLean

 */
#pragma once

#include "Global.h"
#include "AllIFNeurons.h"

// Class to hold all data necessary for all the Neurons.
class AllIZHNeurons : public AllIFNeurons
{
    public:
        AllIZHNeurons();
        virtual ~AllIZHNeurons();

        static AllNeurons* Create() { return new AllIZHNeurons(); }

        //! A constant (0.02, 01) describing the coupling of variable u to Vm;
        BGFLOAT *Aconst;

        //! A constant controlling sensitivity of u
        BGFLOAT *Bconst;

        //! A constant controlling reset of Vm 
        BGFLOAT *Cconst;

        //! A constant controlling reset of u
        BGFLOAT *Dconst;

        //! internal variable
        BGFLOAT *u;

        //!
        BGFLOAT *C3;

        virtual void setupNeurons(SimulationInfo *sim_info);
        virtual void cleanupNeurons();  
        virtual int numParameters();
        virtual bool readParameters(const TiXmlElement& element);
        virtual void printParameters(ostream &output) const;
        virtual void createAllNeurons(SimulationInfo *sim_info, Layout *layout);
        virtual string toString(const int i) const;
        virtual void readNeurons(istream &input, const SimulationInfo *sim_info);
        virtual void writeNeurons(ostream& output, const SimulationInfo *sim_info) const;

#if defined(USE_GPU)
        virtual void allocNeuronDeviceStruct( void** allNeuronsDevice, SimulationInfo *sim_info );
        virtual void deleteNeuronDeviceStruct( void* allNeuronsDevice, const SimulationInfo *sim_info );
        virtual void copyNeuronHostToDevice( void* allNeuronsDevice, const SimulationInfo *sim_info );
        virtual void copyNeuronDeviceToHost( void* allNeuronsDevice, const SimulationInfo *sim_info );
        virtual void copyNeuronDeviceSpikeHistoryToHost( void* allNeuronsDevice, const SimulationInfo *sim_info );
        virtual void copyNeuronDeviceSpikeCountsToHost( void* allNeuronsDevice, const SimulationInfo *sim_info );
        virtual void clearNeuronSpikeCounts( void* allNeuronsDevice, const SimulationInfo *sim_info );

    protected:
        void allocDeviceStruct( AllIZHNeurons &allNeurons, SimulationInfo *sim_info );
        void deleteDeviceStruct( AllIZHNeurons& allNeurons, const SimulationInfo *sim_info );
        void copyHostToDevice( AllIZHNeurons& allNeurons, const SimulationInfo *sim_info );
        void copyDeviceToHost( AllIZHNeurons& allNeurons, const SimulationInfo *sim_info );
#endif

        void createNeuron(SimulationInfo *sim_info, int neuron_index, Layout *layout);
        void setNeuronDefaults(const int index);
        virtual void initNeuronConstsFromParamValues(int neuron_index, const BGFLOAT deltaT);
        void readNeuron(istream &input, const SimulationInfo *sim_info, int i);
        void writeNeuron(ostream& output, const SimulationInfo *sim_info, int i) const;

#if defined(USE_GPU)
        // Update the state of all neurons for a time step
        virtual void advanceNeurons(AllSynapses &synapses, AllNeurons* allNeuronsDevice, AllSynapses* allSynapsesDevice, const SimulationInfo *sim_info, float* randNoise, SynapseIndexMap* synapseIndexMapDevice);
#else
        // Helper for #advanceNeuron. Updates state of a single neuron.
        virtual void advanceNeuron(const int index, const SimulationInfo *sim_info);

        // Initiates a firing of a neuron to connected neurons
        virtual void fire(const int index, const SimulationInfo *sim_info) const;
#endif

    private:
        static const BGFLOAT DEFAULT_a = 0.0035;
        static const BGFLOAT DEFAULT_b = 0.2;
        static const BGFLOAT DEFAULT_c = -50;
        static const BGFLOAT DEFAULT_d = 2;

        // TODO
        BGFLOAT m_Aconst[2];
        // TODO
        BGFLOAT m_Bconst[2];
        // TODO
        BGFLOAT m_Cconst[2];
        // TODO
        BGFLOAT m_Dconst[2];

        void freeResources();  
};
