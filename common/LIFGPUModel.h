/** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\ 
 * @authors Aaron Oziel, Sean Blackbourn 
 *
 * Fumitaka Kawasaki (5/3/14):
 * All functions were completed and working. 
 *
 * Aaron Wrote (2/3/14):
 * This file is extremely out of date and will be need to be updated to
 * reflect changes made to the corresponding .cu file. Functions will need
 * to be added/removed where necessary and the Model super class will need
 * to be edited to reflect a more abstract Model that can be used for both
 * single-threaded and GPU implementations. 
\** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **/

/**
 * @brief A leaky-integrate-and-fire (I&F) neural network model.
 *
 * @class LIFSingleThreadedModel LIFSingleThreadedModel.h "LIFSingleThreadedModel.h"
 *
 * Implements both neuron and synapse behaviour.
 *
 * A standard leaky-integrate-and-fire neuron model is implemented
 * where the membrane potential \f$V_m\f$ of a neuron is given by
 * \f[
 *   \tau_m \frac{d V_m}{dt} = -(V_m-V_{resting}) + R_m \cdot (I_{syn}(t)+I_{inject}+I_{noise})
 * \f]
 * where \f$\tau_m=C_m\cdot R_m\f$ is the membrane time constant,
 * \f$R_m\f$ is the membrane resistance, \f$I_{syn}(t)\f$ is the
 * current supplied by the synapses, \f$I_{inject}\f$ is a
 * non-specific background current and \f$I_{noise}\f$ is a
 * Gaussian random variable with zero mean and a given variance
 * noise.
 *
 * At time \f$t=0\f$ \f$V_m\f$ is set to \f$V_{init}\f$. If
 * \f$V_m\f$ exceeds the threshold voltage \f$V_{thresh}\f$ it is
 * reset to \f$V_{reset}\f$ and hold there for the length
 * \f$T_{refract}\f$ of the absolute refractory period.
 *
 * The exponential Euler method is used for numerical integration.
 * The main idea behind the exponential Euler rule is that many biological 
 * processes are governed by an exponential decay function.
 * For an equation of the form:
 * \f[
 *  \frac{d y}{dt} = A - By
 * \f]
 *
 * its scheme is given by:
 * \f[
 *  y(t+\Delta t) = y(t) \cdot \mathrm{e}^{-B \Delta t} + \frac{A}{B} \cdot (1 - \mathrm{e}^{-B \Delta t})
 * \f]
 *
 * After appropriate substituting all variables, we obtain the exponential Euler step:
 * \f[
 *  V_m(t+\Delta t) = V_m(t) \cdot \mathrm{e}^{-\frac{\Delta t}{\tau_m}} + 
 *  R_m \cdot (I_{syn}(t)+I_{inject}+I_{noise}+\frac{V_{resting}}{R_m}) 
 *  \cdot (1 - \mathrm{e}^{-\frac{\Delta t}{\tau_m}})
 * \f]
 *
 * Phenomenological model of frequency-dependent synapses exibit dynamics that include
 * activity-dependent facilitation and depression (Tsodyks and Markram 1997, Tsodyks et al. 1998). 
 * The model has two state variables: \f$r\f$ (the fraction of available synaptic efficacy), and
 * \f$u\f$ (the running value of utilization of synaptic efficacy).
 *
 * \f[
 *  r_{n+1} = r_n \cdot (1-u_{n+1}) \cdot \mathrm{e}^{-\frac{\Delta t}{\tau_{rec}}} +
 *  1 - \mathrm{e}^{-\frac{\Delta t}{\tau_{rec}}}
 * \f]
 *
 * \f[
 * \f]
 *
 * where \f$\Delta t\f$ is the time interval between nth and (n + 1)th AP,
 * the two time constants \f$\tau_{rec}\f$ and \f$\tau_{facil}\f$ govern recovery from depression,
 * and facilitation after a spike, and \f$U\f$ is utilization of synaptic efficacy (Markram et al. 1998).
 *
 * The synaptic response that is generated by any AP in a train is therefore given by:
 * \f[
 *  EPSP_n = A \cdot r_n \cdot u_n
 * \f]
 *
 * This model is a rewrite of work by Stiber, Kawasaki, Allan Ortiz, and Cory Mayberry
 *
 * @authors Derek McLean
 */

#pragma once
#include "Model.h"
#include "AllLIFNeurons.h"
#include "AllSynapsesDevice.h"
#include "AllDSSynapses.h"
#ifdef __CUDACC__
#include "Book.h"
#endif

const BGFLOAT SYNAPSE_STRENGTH_ADJUSTMENT = 1.0e-8;

/*-----------------------------------------------------*\
|  Inline Functions for handling performance recording
\*-----------------------------------------------------*/
#if defined(PERFORMANCE_METRICS) && defined(__CUDACC__)
extern float g_time;
extern cudaEvent_t start, stop;

inline void startTimer() {
       	cudaEventRecord( start, 0 );
};

inline void lapTime(float& t_event) {
       	cudaEventRecord( stop, 0 );
       	cudaEventSynchronize( stop );
       	cudaEventElapsedTime( &g_time, start, stop );
       	t_event += g_time;
};
#endif // PERFORMANCE_METRICS

class GpuSInputPoisson;

class LIFGPUModel : public Model  {
	friend GpuSInputPoisson;

public:
	LIFGPUModel(Connections *conns, AllNeurons *neurons, AllSynapses *synapses, Layout *layout);
	virtual ~LIFGPUModel();
 
	virtual void setupSim(SimulationInfo *sim_info, IRecorder* simRecorder);
        virtual void loadMemory(istream& input, const SimulationInfo *sim_info);
	virtual void advance(const SimulationInfo *sim_info);
	virtual void updateConnections(const int currentStep, const SimulationInfo *sim_info, IRecorder* simRecorder);
	virtual void cleanupSim(SimulationInfo *sim_info);

	struct SynapseIndexMap
	{
		//! The beginning index of the incoming dynamic spiking synapse array.
		int* incomingSynapse_begin;

		//! The number of incoming synapses.
		int* synapseCount;

		//! Pointer to the synapse inverse map.
		uint32_t* inverseIndex;	

		//! Pointer to the active synapse map.
		uint32_t* activeSynapseIndex;

		SynapseIndexMap() : num_neurons(0), num_synapses(0)
		{
			incomingSynapse_begin = NULL;
			synapseCount = NULL;
			inverseIndex = NULL;	
			activeSynapseIndex = NULL;
		};

		SynapseIndexMap(int neuron_count, int synapse_count) : num_neurons(neuron_count), num_synapses(synapse_count)
		{
			incomingSynapse_begin = new int[neuron_count];
			synapseCount = new int[neuron_count];
			inverseIndex = new uint32_t[synapse_count];
			activeSynapseIndex = new uint32_t[synapse_count];
		};

		~SynapseIndexMap()
		{
			if (num_neurons != 0) {
				delete[] incomingSynapse_begin;
				delete[] synapseCount;
			}
			if (num_synapses != 0) {
				delete[] inverseIndex;
				delete[] activeSynapseIndex;
			}
		}

	private:
		int num_neurons;
		int num_synapses;	
	};

private: 
	/* ------------------*\
	|* # Helper Functions
	\* ------------------*/

	void allocDeviceStruct(const SimulationInfo *sim_info, const AllLIFNeurons &allNeuronsHost, AllDSSynapses &allSynapsesHost);
	void allocNeuronDeviceStruct( int count, int max_spikes );
	void deleteNeuronDeviceStruct( int count );
	void copyNeuronHostToDevice( const AllLIFNeurons& allNeuronsHost, int count );
	void copyNeuronDeviceToHost( AllLIFNeurons& allNeuronsHost, int count );

	void allocSynapseDeviceStruct( AllSynapsesDevice*& allSynapsesDevice, int num_neurons, int max_synapses );
	void deleteSynapseDeviceStruct( AllSynapsesDevice* allSynapsesDevice, int num_neurons, int max_synapses );
	void copySynapseHostToDevice( AllSynapsesDevice* allSynapsesDevice, const AllDSSynapses& allSynapsesHost, int num_neurons, int max_synapses );
	void copySynapseDeviceToHost( AllSynapsesDevice* allSynapsesDevice, AllDSSynapses& allSynapsesHost, int num_neurons, int max_synapses );

	void allocSynapseImap( int count );
	void deleteSynapseImap( );
	void copySynapseIndexMapHostToDevice(SynapseIndexMap &synapseIndexMapHost, int neuron_count, int synapse_count);
	void copyDeviceSynapseCountsToHost(AllSynapses &allSynapsesHost, int neuron_count);
	void copyDeviceSynapseSumCoordToHost(AllSynapses &allSynapsesHost, int neuron_count, int max_synapses);
	void createSynapseImap( AllSynapses &synapses, const SimulationInfo* sim_info );

	// # Load Memory
	// -------------

	// # Create All Neurons
	// --------------------

	// # Advance Network/Model
	// -----------------------

	// # Update Connections
	// --------------------

	// TODO
	void updateHistory(const int currentStep, BGFLOAT epochDuration, AllNeurons &neuron, const SimulationInfo *sim_infos, IRecorder* simRecorder);
	// TODO
	void updateWeights(const int num_neurons, AllNeurons &neurons, AllSynapses &synapses, const SimulationInfo *sim_info);
	// TODO
	void copyDeviceSpikeHistoryToHost(AllLIFNeurons &allNeuronsHost, const SimulationInfo *sim_info);
	//
	void copyDeviceSpikeCountsToHost(AllLIFNeurons &allNeuronsHost, int numNeurons);
	// TODO
	void clearSpikeCounts(int numNeurons);

	// TODO
	void eraseSynapse(AllSynapses &synapses, const int neuron_index, const int synapse_index);
	// TODO
	void addSynapse(AllSynapses &synapses, synapseType type, const int src_neuron, const int dest_neuron, Coordinate &source, Coordinate &dest, BGFLOAT *sum_point, BGFLOAT deltaT);
	// TODO
	void createSynapse(AllSynapses &synapses, const int neuron_index, const int synapse_index, Coordinate source, Coordinate dest, BGFLOAT* sp, BGFLOAT deltaT, synapseType type);

	/*----------------------------------------------*\
	|  Generic Functions for handling synapse types
	\*----------------------------------------------*/


	/*----------------------------------------------*\
	|  Member variables
	\*----------------------------------------------*/

	//! Neuron structure in device memory.
	AllLIFNeurons* allNeuronsDevice;

	//! Synapse structures in device memory.
	AllSynapsesDevice* allSynapsesDevice;

	//! Pointer to device random noise array.
	float* randNoise_d;

	//! Pointer to synapse index map in device memory.
	SynapseIndexMap* synapseIndexMapDevice;
};
